[{"title":"aidl_issues","date":"2017-04-19T16:00:00.000Z","path":"2017/04/20/aidl-issues/","text":"前言记录aidl开发过程中遇到的问题。 issue 0因为最近需要开发服务来进行IPC，以前并未做过开发，所以很多东西都是新接触，以下记录下我碰到的奇葩的问题及解决方法。 issue 1前提：aidl文件是客户提供的，aidl的Project是Eclipse的。虽说电脑上有Eclipse和Android Studio，针对新项目，还是希望用Android Studio开发，然后就碰到了各种坑！ 问题：错误: 找不到符号 符号: 类 BeeperStub 位置: 程序包 com.**.beeper 错误: 找不到符号 符号: 类 BeeperStub 位置: 类 UService 说明：开发环境：Android Studio 2.3.1 / buildToolsVersion 25.0.2 需要Beeper.aidl文件中的方法，便在com.xx.beeper下写了BeeperStub类，继承com.xx.beeper.Beeper类，Service中返回BeeperStub的实例。代码写好后（编写的时候，Android Studio并未报错，包都能正确导入），编译，报上面的错。 失败的解决方法：说明：下面的解决办法，在网上搜集，可能针对其他情况能解决问题，但并不适合我这里的情况。 1、aidl的路径配置到module目录的gradle的android {}中 android { compileSdkVersion 25 buildToolsVersion &quot;25.0.2&quot; defaultConfig { //... } sourceSets { main { manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/aidl&apos;] resources.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/aidl&apos;] aidl.srcDirs = [&apos;src/main/aidl&apos;] res.srcDirs = [&apos;src/main/res&apos;] assets.srcDirs = [&apos;src/main/assets&apos;] } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } } 感觉将源文件都添加到gradle中，编译器应该就能找到，但编译仍旧报错。 2、注释module目录下gradle中的buildTypes的release的配置，当然，我这里只有混淆的配置，所以并没有任何用处。 3、将BeeperStub.java移到package的包路径下以及将Beeper.aidl移到package的包路径下，网上很多例程都是在package的路径下添加aidl文件及Java文件。编译仍旧报错。 4、因为文件是从Eclipse下move到Android Studio中的，所以曾怀疑是不是文件编码格式不对导致。修改文件编码格式。编译仍旧报错。 正确的解决方法：在查找问题及解决方法的过程中，发现，从Github上下载的例程，在上面新建Beeper.aidl及BeeperStub.java，然后编译，程序是能够正确编译安装的。于是，我在自己工程中新建Beeper.aidl及BeeperStub.java，然后编译，问题解决了。 用Beyond Compare对比之前的工程以及新建aidl的工程，发现，全部有差异的文件中，跟Beeper相关的就只有.idea文件夹下的workspace.xml文件，workspace是Android Studio自动生成的，所以可以得出结论： aidl文件需要通过Android Studio新建，复制粘贴的aidl文件会因为在编译配置中没有添加导致编译出错 后面自己想想，网上大部分的例程都是作者自己新建的，所以并不会出现这种情况。 4月21日 注：Java文件也需要新建而不是直接拷贝","comments":true,"tags":[{"name":"aidl","slug":"aidl","permalink":"https://mraugust.github.io/tags/aidl/"}]},{"title":"JNI开发","date":"2017-04-10T16:00:00.000Z","path":"2017/04/11/jni-develop/","text":"官方规范: Java Native Interface Specification 官方规范中文版: JNI规范 - 农场老马的专栏 官方规范中文版：JNI技术规范 - 骆驼骑士 Android Develop training: JNI Tips Android Develop training: JNI Tips中文版 前言本想对官方规范做个理解性的翻译，但农场老马和骆驼骑士对官方规范进行一定翻译并加上了他们的理解，Android的JNI Tips也有相关翻译，我再做翻译会有点重复了。 下面我就梳理下知识点，总结下自己在开发过程中碰到的问题及解决方法。本人开发过的JNI代码属于工具类，业务类的JNI代码，暂未上线，也未经过严格测试，所以对JNI的高级用法，理解上可能不规范，若有不对之处，敬请指出！ 1.hello-jni下文使用的JNI例子，编译环境是Eclipse及NDK，借鉴官方的hello-jni的例子。 路径：hello-jni 2.自动生成Android.mk和Application.mk在使用ndk-build命令来编译so库的时候，往往需要我们编写Android.mk和Application.mk文件，但Android.mk在添加c/cpp文件的时候，如果是自己一个个添加的话，真的是要敲到手酸，当然，我们也可以借助工具：Android.mk生成工具，也可以参考Android.mk 生成代码自己开发一个小工具。 填坑1：该工具自动生成的Applicatin.mk文件，单词拼写错误，需要修改为Application.mk，不然在Application.mk中设置的ABI无法生效。ABI有以下几种：arm64-v8a / armeabi / armeabi-v7a / mips/ mips64 / x86 / x86_64，通过 adb shell，cat /proc/cpuinfo 可以查看当前手机的CPU信息 填坑2：开发APP时可能会使用到三方的so库，可能三方的so库支持的CPU架构较多，而我们自己的so库，只支持几种CPU架构，这个时候，放置三方so库时，只能挑选我们自己so库支持的CPU架构的三方so库，比如我们编译了armeabi的so库，三方编译了armeabi和x86的so库，这个时候如果运行在x86的手机上，就会报错。 3.JNI_OnLoadJNI_OnLoad方法是加载so库会进行的回调，如Activity的onCreate方法。这个方法，我们可以这么写： JavaVM *g_jvm; JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } g_jvm = vm; // 使用(*env)-&gt;FindClass得到jclass // 使用(*env)-&gt;RegisterNatives注册本地方法 // 本人注：这里使用的注册本地方法为动态注册JNI方法（详见2.动态注册） return JNI_VERSION_1_6; } 将JavaVM保存为全局，方便后续代码可以获取当前线程的JNIEnv（JNIEnv是用作线程局部存储。因此，你不能在线程间共享一个JNIEnv变量）。有人会说Java调用本地方法时不是会传入JNIEnv吗？但有时候，我们写的代码比较深，或者代码已经有现成的了，我们是在该代码基础上添加JNI来方便Java调用，这时候，调用以下代码就可以方便的获取JNIEnv。 JNIEnv *env; if((*g_jvm)-&gt;AttachCurrentThread(g_jvm, &amp;env, NULL) != JNI_OK) { return -1; } //...使用JNIEnv (*g_jvm)-&gt;DetachCurrentThread(g_jvm); 4.动态注册写JNI方法时，有两种方式。 一种是带上包名，如Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz ) 另外一种就是进行动态注册，动态注册的好处就是当你的方法需要修改包路径时，就不需要每个函数都进行修改 # define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0]))) jstring native_stringFromJNI( JNIEnv* env, jobject thiz ) { return (*env)-&gt;NewStringUTF(env, &quot;Hello from JNI !&quot;); } static const char *classPathName = &quot;com/example/hellojni/HelloJni&quot;; static JNINativeMethod methods[] = { {&quot;stringFromJNI&quot;, &quot;()Ljava/lang/String;&quot;, (void*)native_stringFromJNI}, }; jint JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; jclass clazz; //获取JNI环境对象 if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } //注册本地方法.Load 目标类 clazz = (*env)-&gt;FindClass(env,classPathName); if (clazz == NULL) { return JNI_ERR; } //注册本地native方法 if((*env)-&gt;RegisterNatives(env, clazz, methods, NELEM(methods)) &lt; 0) { return JNI_ERR; } return JNI_VERSION_1_6; } 5.Log在写本地方法时难免要添加一些log来方便自己查看数据及定位问题，log打印方法如下： #include &lt;android/log.h&gt; #define TAG &quot;HELLO&quot; #define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, TAG, __VA_ARGS__) #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG , TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__) #define LOGW(...) __android_log_print(ANDROID_LOG_WARN , TAG, __VA_ARGS__) #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR , TAG, __VA_ARGS__) 6.代码问题定位刚接触JNI的时候，曾非常反感写JNI，因为JNI不像JAVA，有时候一些简单的错，也不好定位，Android Monitor上只会显示一些堆栈信息，如下图所示： 造成crash的代码见hello-jni 这时候，我们就需要借助arm-linux-androideabi-addr2line命令，该命令可以在android-ndk-r9c/toolchains/arm-linux-androideabi-4.8/prebuilt/darwin-x86_64/bin（单独下载的NDK的路径）下或者android-sdk-macosx/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin（Android Studio中下载的NDK的路径）中查看。可以将该命令配置到环境变量中方便调用。 cd到工程目录下后（需确定手机的CPU架构，adb shell，cat /proc/cpuinfo 获取），执行以下命令来定位出错的函数信息 arm-linux-androideabi-addr2line -C -f -e obj/local/armeabi-v7a/libhello-jni.so 00000ff0 返回崩溃的文件、行号、函数名 native_stringFromJNI /Users/wangyuan/Documents/Workspace/hello-jni/jni/hello-jni.c:52 有了这些，还愁找不到bug吗？ 填坑：用来定位的so库必须为obj/local下的so文件，不是libs目录下生成的so文件","comments":true,"tags":[{"name":"JNI","slug":"JNI","permalink":"https://mraugust.github.io/tags/JNI/"}]},{"title":"Hello World","date":"2017-03-08T06:45:29.000Z","path":"2017/03/08/hello-world/","text":"欢迎来到我的博客！ 博客的搭建，感谢以下组织及前人： 1、博客的搭建： Github hexo Mac上搭建基于GitHub的Hexo博客 手把手教你用Hexo+Github 搭建属于自己的博客 网易云跟帖初次使用手记 2、Hexo主题 hexo-theme-yilia","comments":true,"tags":[{"name":"others","slug":"others","permalink":"https://mraugust.github.io/tags/others/"}]}]