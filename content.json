[{"title":"JNI开发","date":"2017-04-10T16:00:00.000Z","path":"2017/04/11/jni-develop/","text":"官方规范: Java Native Interface Specification 官方规范中文版: JNI规范 - 农场老马的专栏 官方规范中文版：JNI技术规范 - 骆驼骑士 Android Develop training: JNI Tips Android Develop training: JNI Tips中文版 前言本想对官方规范做个理解性的翻译，但农场老马和骆驼骑士对官方规范进行一定翻译并加上了他们的理解，Android的JNI Tips也有相关翻译，我再做翻译会有点重复了。 下面我就梳理下知识点，总结下自己在开发过程中碰到的问题及解决方法。本人开发过的JNI代码属于工具类，业务类的JNI代码，暂未上线，也未经过严格测试，所以对JNI的高级用法，理解上可能不规范，若有不对之处，敬请指出！ 1.hello-jni下文使用的JNI例子，编译环境是Eclipse及NDK，借鉴官方的hello-jni的例子。 路径：hello-jni 2.自动生成Android.mk和Application.mk在使用ndk-build命令来编译so库的时候，往往需要我们编写Android.mk和Application.mk文件，但Android.mk在添加c/cpp文件的时候，如果是自己一个个添加的话，真的是要敲到手酸，当然，我们也可以借助工具：Android.mk生成工具，也可以参考Android.mk 生成代码自己开发一个小工具。 填坑1：该工具自动生成的Applicatin.mk文件，单词拼写错误，需要修改为Application.mk，不然在Application.mk中设置的ABI无法生效。ABI有以下几种：arm64-v8a / armeabi / armeabi-v7a / mips/ mips64 / x86 / x86_64，通过 adb shell，cat /proc/cpuinfo 可以查看当前手机的CPU信息 填坑2：开发APP时可能会使用到三方的so库，可能三方的so库支持的CPU架构较多，而我们自己的so库，只支持几种CPU架构，这个时候，放置三方so库时，只能挑选我们自己so库支持的CPU架构的三方so库，比如我们编译了armeabi的so库，三方编译了armeabi和x86的so库，这个时候如果运行在x86的手机上，就会报错。 3.JNI_OnLoadJNI_OnLoad方法是加载so库会进行的回调，如Activity的onCreate方法。这个方法，我们可以这么写： JavaVM *g_jvm; JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } g_jvm = vm; // 使用(*env)-&gt;FindClass得到jclass // 使用(*env)-&gt;RegisterNatives注册本地方法 // 本人注：这里使用的注册本地方法为动态注册JNI方法（详见2.动态注册） return JNI_VERSION_1_6; } 将JavaVM保存为全局，方便后续代码可以获取当前线程的JNIEnv（JNIEnv是用作线程局部存储。因此，你不能在线程间共享一个JNIEnv变量）。有人会说Java调用本地方法时不是会传入JNIEnv吗？但有时候，我们写的代码比较深，或者代码已经有现成的了，我们是在该代码基础上添加JNI来方便Java调用，这时候，调用以下代码就可以方便的获取JNIEnv。 JNIEnv *env; if((*g_jvm)-&gt;AttachCurrentThread(g_jvm, &amp;env, NULL) != JNI_OK) { return -1; } //...使用JNIEnv (*g_jvm)-&gt;DetachCurrentThread(g_jvm); 4.动态注册写JNI方法时，有两种方式。 一种是带上包名，如Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz ) 另外一种就是进行动态注册，动态注册的好处就是当你的方法需要修改包路径时，就不需要每个函数都进行修改 # define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0]))) jstring native_stringFromJNI( JNIEnv* env, jobject thiz ) { return (*env)-&gt;NewStringUTF(env, &quot;Hello from JNI !&quot;); } static const char *classPathName = &quot;com/example/hellojni/HelloJni&quot;; static JNINativeMethod methods[] = { {&quot;stringFromJNI&quot;, &quot;()Ljava/lang/String;&quot;, (void*)native_stringFromJNI}, }; jint JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; jclass clazz; //获取JNI环境对象 if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } //注册本地方法.Load 目标类 clazz = (*env)-&gt;FindClass(env,classPathName); if (clazz == NULL) { return JNI_ERR; } //注册本地native方法 if((*env)-&gt;RegisterNatives(env, clazz, methods, NELEM(methods)) &lt; 0) { return JNI_ERR; } return JNI_VERSION_1_6; } 5.Log在写本地方法时难免要添加一些log来方便自己查看数据及定位问题，log打印方法如下： #include &lt;android/log.h&gt; #define TAG &quot;HELLO&quot; #define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, TAG, __VA_ARGS__) #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG , TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__) #define LOGW(...) __android_log_print(ANDROID_LOG_WARN , TAG, __VA_ARGS__) #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR , TAG, __VA_ARGS__) 6.代码问题定位刚接触JNI的时候，曾非常反感写JNI，因为JNI不像JAVA，有时候一些简单的错，也不好定位，Android Monitor上只会显示一些堆栈信息，如下图所示： 造成crash的代码见hello-jni 这时候，我们就需要借助arm-linux-androideabi-addr2line命令，该命令可以在android-ndk-r9c/toolchains/arm-linux-androideabi-4.8/prebuilt/darwin-x86_64/bin（单独下载的NDK的路径）下或者android-sdk-macosx/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin（Android Studio中下载的NDK的路径）中查看。可以将该命令配置到环境变量中方便调用。 cd到工程目录下后（需确定手机的CPU架构，adb shell，cat /proc/cpuinfo 获取），执行以下命令来定位出错的函数信息 arm-linux-androideabi-addr2line -C -f -e obj/local/armeabi-v7a/libhello-jni.so 00000ff0 返回崩溃的文件、行号、函数名 native_stringFromJNI /Users/wangyuan/Documents/Workspace/hello-jni/jni/hello-jni.c:52 有了这些，还愁找不到bug吗？ 填坑：用来定位的so库必须为obj/local下的so文件，不是libs目录下生成的so文件","comments":true,"tags":[{"name":"JNI","slug":"JNI","permalink":"https://mraugust.github.io/tags/JNI/"}]},{"title":"Hello World","date":"2017-03-08T06:45:29.000Z","path":"2017/03/08/hello-world/","text":"欢迎来到我的博客！ 博客的搭建，感谢以下组织及前人： 1、博客的搭建： Github hexo Mac上搭建基于GitHub的Hexo博客 手把手教你用Hexo+Github 搭建属于自己的博客 网易云跟帖初次使用手记 2、Hexo主题 hexo-theme-yilia","comments":true,"tags":[{"name":"others","slug":"others","permalink":"https://mraugust.github.io/tags/others/"}]}]